/**
 * SENTIMENT-ONCHAIN DIVERGENCE STRATEGY
 * 
 * Generated by Grok Ideation Agent
 * AlphaScore: 8/10 | Complexity: medium
 * 
 * Quantifie divergence entre X/Twitter sentiment score et whale positions.
 * Long quand sentiment bearish mais whales sont long (divergence resolution).
 * 
 * Entry: x_sent < -0.2 && whale_net > 0.6 && div_score > 1.5Ïƒ
 * Exit: div_score < 0.5 or 4% pnl or 48h timeout
 * Risk: Half-Kelly, max 0.8% capital, trailing stop 1.5%
 */

const config = require("../config");

// Whale addresses we track
const WHALE_ADDRESSES = Object.keys(config.WHALES);

class SentimentDivergenceStrategy {
  constructor() {
    this.name = "sentiment_divergence";
    this.description = "Trade divergence between social sentiment and whale positions";
  }

  /**
   * Fetch whale positions and calculate net direction
   */
  async getWhaleNetPosition(marketSlug) {
    let longCount = 0;
    let shortCount = 0;
    let totalValue = 0;

    for (const address of WHALE_ADDRESSES) {
      try {
        const resp = await fetch(
          `https://data-api.polymarket.com/positions?user=${address}`
        );
        const positions = await resp.json();
        
        for (const pos of positions) {
          if (!pos.eventSlug?.includes(marketSlug) && 
              !pos.title?.toLowerCase().includes("bitcoin")) continue;
          
          const value = pos.currentValue || 0;
          if (value < 1000) continue; // Min $1k position
          
          totalValue += value;
          const isLong = pos.outcome?.toLowerCase().includes("yes") ||
                        pos.outcome?.toLowerCase().includes("up");
          if (isLong) longCount += value;
          else shortCount += value;
        }
      } catch (e) {
        // Skip failed fetches
      }
      await new Promise(r => setTimeout(r, 200)); // Rate limit
    }

    if (totalValue === 0) return { net: 0, confidence: 0 };
    
    const net = (longCount - shortCount) / totalValue;
    return {
      net, // -1 to 1 (negative = net short, positive = net long)
      longValue: longCount,
      shortValue: shortCount,
      totalValue,
      confidence: Math.min(totalValue / 100000, 1), // More $ = more confident
    };
  }

  /**
   * Get sentiment from Fear & Greed (proxy for X sentiment)
   * In production, would use actual X/Twitter API
   */
  async getSentiment() {
    try {
      const resp = await fetch("https://api.alternative.me/fng/");
      const data = await resp.json();
      const fng = parseInt(data.data[0].value);
      
      // Convert to -1 to 1 scale
      // 0-25 = extreme fear = -1 to -0.5
      // 25-50 = fear = -0.5 to 0
      // 50-75 = greed = 0 to 0.5
      // 75-100 = extreme greed = 0.5 to 1
      const normalized = (fng - 50) / 50;
      
      return {
        score: normalized,
        raw: fng,
        classification: data.data[0].value_classification,
      };
    } catch (e) {
      return { score: 0, raw: 50, classification: "neutral" };
    }
  }

  /**
   * Calculate divergence score between sentiment and whale positions
   */
  calculateDivergence(sentiment, whaleNet) {
    // Divergence = when sentiment and whales disagree
    // High divergence when: sentiment bearish (-) but whales long (+)
    // or sentiment bullish (+) but whales short (-)
    
    const divergence = Math.abs(sentiment.score - whaleNet.net);
    
    // Standard deviation approximation (historical avg divergence ~0.3)
    const historicalMean = 0.3;
    const historicalStd = 0.2;
    const zScore = (divergence - historicalMean) / historicalStd;
    
    return {
      raw: divergence,
      zScore,
      isSignificant: zScore > 1.5,
      direction: whaleNet.net > 0 ? "LONG" : "SHORT", // Follow whales
    };
  }

  /**
   * Main analysis
   */
  async analyze(marketSlug) {
    console.log(`\nðŸ“Š Sentiment Divergence Analysis...`);

    // Get data
    const [sentiment, whaleNet] = await Promise.all([
      this.getSentiment(),
      this.getWhaleNetPosition(marketSlug),
    ]);

    console.log(`   Sentiment: ${(sentiment.score * 100).toFixed(0)}% (${sentiment.classification})`);
    console.log(`   Whale Net: ${(whaleNet.net * 100).toFixed(0)}% ($${(whaleNet.totalValue/1000).toFixed(0)}k tracked)`);

    // Calculate divergence
    const divergence = this.calculateDivergence(sentiment, whaleNet);
    console.log(`   Divergence: ${divergence.zScore.toFixed(2)}Ïƒ`);

    // Entry conditions
    // Original: x_sent < -0.2 && whale_net > 0.6 && div_score > 1.5Ïƒ
    const sentimentBearish = sentiment.score < -0.2;
    const whalesLong = whaleNet.net > 0.6;
    const significantDiv = divergence.zScore > 1.5;

    if (sentimentBearish && whalesLong && significantDiv) {
      console.log(`   ðŸŽ¯ DIVERGENCE SIGNAL: Sentiment bearish but whales long!`);
      
      return {
        strategy: "creative:sentiment_divergence",
        score: 0.6, // Bullish (follow whales)
        confidence: whaleNet.confidence * 0.8,
        recommendation: {
          action: "BUY_UP",
          reason: `Sentiment ${(sentiment.score*100).toFixed(0)}% vs Whales ${(whaleNet.net*100).toFixed(0)}% (${divergence.zScore.toFixed(1)}Ïƒ div)`,
        },
        reason: `Divergence: bearish sentiment but ${(whaleNet.net*100).toFixed(0)}% whale long`,
        data: { sentiment, whaleNet, divergence },
      };
    }

    // Inverse: sentiment bullish but whales short
    const sentimentBullish = sentiment.score > 0.2;
    const whalesShort = whaleNet.net < -0.6;

    if (sentimentBullish && whalesShort && significantDiv) {
      console.log(`   ðŸŽ¯ DIVERGENCE SIGNAL: Sentiment bullish but whales short!`);
      
      return {
        strategy: "creative:sentiment_divergence",
        score: -0.6, // Bearish (follow whales)
        confidence: whaleNet.confidence * 0.8,
        recommendation: {
          action: "BUY_DOWN",
          reason: `Sentiment ${(sentiment.score*100).toFixed(0)}% vs Whales ${(whaleNet.net*100).toFixed(0)}% (${divergence.zScore.toFixed(1)}Ïƒ div)`,
        },
        reason: `Divergence: bullish sentiment but ${(whaleNet.net*100).toFixed(0)}% whale short`,
        data: { sentiment, whaleNet, divergence },
      };
    }

    // No significant divergence
    return {
      strategy: "creative:sentiment_divergence",
      score: 0,
      confidence: 0.3,
      recommendation: { action: "HOLD", reason: "No significant divergence" },
      reason: `Div ${divergence.zScore.toFixed(1)}Ïƒ < 1.5Ïƒ threshold`,
      data: { sentiment, whaleNet, divergence },
    };
  }
}

module.exports = SentimentDivergenceStrategy;
