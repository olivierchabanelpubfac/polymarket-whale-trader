<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üêã Whale Trader Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d1117; 
      color: #c9d1d9; 
      padding: 20px;
    }
    h1 { color: #58a6ff; margin-bottom: 20px; }
    h2 { color: #8b949e; margin: 20px 0 10px; font-size: 1.1em; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
    .card { 
      background: #161b22; 
      border: 1px solid #30363d; 
      border-radius: 8px; 
      padding: 20px; 
    }
    .card.full { grid-column: 1 / -1; }
    .stat { text-align: center; }
    .stat .value { font-size: 2em; font-weight: bold; color: #58a6ff; }
    .stat .label { color: #8b949e; font-size: 0.9em; }
    .stat.profit .value { color: #3fb950; }
    .stat.loss .value { color: #f85149; }
    table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #30363d; }
    th { color: #8b949e; }
    .real { color: #3fb950; }
    .paper { color: #8b949e; }
    .buy-up { color: #3fb950; }
    .buy-down { color: #f85149; }
    canvas { max-height: 300px; }
    .refresh { 
      position: fixed; bottom: 20px; right: 20px; 
      background: #238636; color: white; border: none; 
      padding: 10px 20px; border-radius: 6px; cursor: pointer;
    }
    .refresh:hover { background: #2ea043; }
  </style>
</head>
<body>
  <h1>üêã Whale Trader Dashboard</h1>
  
  <div class="grid">
    <div class="card stat">
      <div class="value" id="balance">--</div>
      <div class="label">USDC Balance</div>
    </div>
    <div class="card stat" id="pnl-card">
      <div class="value" id="pnl">--</div>
      <div class="label">P&L Total</div>
    </div>
    <div class="card stat">
      <div class="value" id="invested">--</div>
      <div class="label">Positions (investies)</div>
    </div>
    <div class="card stat">
      <div class="value" id="champion">--</div>
      <div class="label">Champion</div>
    </div>
  </div>

  <div class="card full">
    <h2>üìà √âvolution du Capital</h2>
    <canvas id="balanceChart"></canvas>
  </div>

  <div class="grid">
    <div class="card">
      <h2>üèÜ Performance par Strat√©gie</h2>
      <canvas id="strategyChart"></canvas>
    </div>
    <div class="card">
      <h2>üìä R√©partition des Trades</h2>
      <canvas id="pieChart"></canvas>
    </div>
  </div>

  <div class="card full">
    <h2>üìú Historique des Trades</h2>
    <table id="tradesTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Strat√©gie</th>
          <th>Action</th>
          <th>Prix</th>
          <th>Taille</th>
          <th>Type</th>
          <th>P&L</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <button class="refresh" onclick="loadData()">üîÑ Refresh</button>

  <script>
    // Configuration
    const WALLET = '0xd34dB22ec11036Fb9e705c1f54614A8270a37Ca5';
    const INITIAL_BALANCE = 346.13; // USDC initial
    let balanceChart, strategyChart, pieChart;
    let onChainBalance = null;

    async function loadData() {
      try {
        // Load trades
        const tradesResp = await fetch('data/paper-trades.json');
        const tradesData = await tradesResp.json();
        
        // Load arena state
        const arenaResp = await fetch('data/arena-state.json');
        const arenaData = await arenaResp.json();
        
        // Load positions
        const posResp = await fetch('data/positions.json');
        const positions = await posResp.json();
        
        // Try to load on-chain balance from balance.json (updated by cron)
        try {
          const balResp = await fetch('data/balance.json');
          const balData = await balResp.json();
          onChainBalance = balData.usdc;
        } catch (e) {
          onChainBalance = null;
        }
        
        renderDashboard(tradesData.trades, arenaData, positions);
      } catch (e) {
        console.error('Error loading data:', e);
      }
    }

    function renderDashboard(trades, arena, positions) {
      const realTrades = trades.filter(t => t.isReal);
      
      // Use on-chain balance if available, otherwise estimate from positions
      const positionValue = Object.values(positions).reduce((s, p) => s + (p.size || 0), 0);
      const estimatedBalance = onChainBalance !== null ? onChainBalance : (INITIAL_BALANCE - positionValue);
      
      // Calculate P&L (simplified: if market resolved, we'd know)
      // For now, assume open positions at current price
      let totalPnL = 0;
      for (const t of realTrades) {
        if (t.pnl !== null) {
          totalPnL += t.pnl;
        }
      }

      // Calculate total value
      const totalValue = estimatedBalance + positionValue;
      
      // Update stats
      document.getElementById('balance').textContent = `$${estimatedBalance.toFixed(2)}`;
      document.getElementById('pnl').textContent = `$${totalValue.toFixed(2)}`;
      document.getElementById('pnl-card').querySelector('.label').textContent = 'Total (USDC + Pos)';
      document.getElementById('invested').textContent = `$${positionValue.toFixed(2)}`;
      document.getElementById('champion').textContent = arena.champion || 'baseline';
      
      const pnlCard = document.getElementById('pnl-card');
      pnlCard.classList.add('profit'); // Total is always shown as positive

      // Balance chart
      renderBalanceChart(realTrades, positions);
      
      // Strategy comparison
      renderStrategyChart(trades);
      
      // Pie chart
      renderPieChart(trades);
      
      // Trades table
      renderTradesTable(trades);
    }

    function renderBalanceChart(realTrades, positions) {
      const ctx = document.getElementById('balanceChart').getContext('2d');
      
      // Calculate position value
      const positionValue = Object.values(positions).reduce((s, p) => s + (p.size || 0), 0);
      
      // Build timeline with two series: USDC (liquid) and Invested (positions)
      let liquid = INITIAL_BALANCE;
      let invested = 0;
      
      const liquidPoints = [{ x: new Date(realTrades[0]?.timestamp - 3600000 || Date.now()), y: liquid }];
      const investedPoints = [{ x: new Date(realTrades[0]?.timestamp - 3600000 || Date.now()), y: 0 }];
      const totalPoints = [{ x: new Date(realTrades[0]?.timestamp - 3600000 || Date.now()), y: liquid }];
      
      for (const t of realTrades) {
        liquid -= t.size;
        invested += t.size;
        const ts = new Date(t.timestamp);
        liquidPoints.push({ x: ts, y: liquid });
        investedPoints.push({ x: ts, y: invested });
        totalPoints.push({ x: ts, y: liquid + invested });
      }
      
      // Add current point (use on-chain balance if available)
      const now = new Date();
      const currentLiquid = onChainBalance || liquid;
      liquidPoints.push({ x: now, y: currentLiquid });
      investedPoints.push({ x: now, y: positionValue });
      totalPoints.push({ x: now, y: currentLiquid + positionValue });

      if (balanceChart) balanceChart.destroy();
      balanceChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Total (USDC + Positions)',
              data: totalPoints,
              borderColor: '#3fb950',
              backgroundColor: 'rgba(63, 185, 80, 0.1)',
              fill: false,
              tension: 0.1,
              borderWidth: 2,
            },
            {
              label: 'USDC Liquide',
              data: liquidPoints,
              borderColor: '#58a6ff',
              backgroundColor: 'rgba(88, 166, 255, 0.3)',
              fill: true,
              tension: 0.1,
            },
            {
              label: 'Positions (investies)',
              data: investedPoints,
              borderColor: '#d29922',
              backgroundColor: 'rgba(210, 153, 34, 0.3)',
              fill: true,
              tension: 0.1,
            }
          ]
        },
        options: {
          responsive: true,
          scales: {
            x: { type: 'time', time: { unit: 'hour' }, grid: { color: '#30363d' } },
            y: { grid: { color: '#30363d' }, beginAtZero: true, stacked: false }
          },
          plugins: { 
            legend: { 
              display: true, 
              position: 'top',
              labels: { color: '#c9d1d9' }
            } 
          }
        }
      });
    }

    function renderStrategyChart(trades) {
      const ctx = document.getElementById('strategyChart').getContext('2d');
      
      // Group by strategy
      const byStrategy = {};
      for (const t of trades) {
        if (!byStrategy[t.strategy]) byStrategy[t.strategy] = { trades: 0, volume: 0, pnl: 0 };
        byStrategy[t.strategy].trades++;
        byStrategy[t.strategy].volume += t.size;
        byStrategy[t.strategy].pnl += t.pnl || 0;
      }

      const labels = Object.keys(byStrategy);
      const data = labels.map(s => byStrategy[s].trades);

      if (strategyChart) strategyChart.destroy();
      strategyChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Trades',
            data,
            backgroundColor: labels.map((_, i) => 
              ['#58a6ff', '#3fb950', '#f85149', '#d29922', '#a371f7', '#8b949e'][i % 6]
            ),
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { grid: { color: '#30363d' }, beginAtZero: true }
          },
          plugins: { legend: { display: false } }
        }
      });
    }

    function renderPieChart(trades) {
      const ctx = document.getElementById('pieChart').getContext('2d');
      
      const real = trades.filter(t => t.isReal).length;
      const paper = trades.filter(t => !t.isReal).length;

      if (pieChart) pieChart.destroy();
      pieChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['Real', 'Paper'],
          datasets: [{
            data: [real, paper],
            backgroundColor: ['#3fb950', '#8b949e'],
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'bottom', labels: { color: '#c9d1d9' } }
          }
        }
      });
    }

    function renderTradesTable(trades) {
      const tbody = document.querySelector('#tradesTable tbody');
      tbody.innerHTML = '';
      
      // Most recent first
      const sorted = [...trades].sort((a, b) => b.timestamp - a.timestamp);
      
      for (const t of sorted.slice(0, 50)) {
        const row = document.createElement('tr');
        const date = new Date(t.timestamp).toLocaleString('fr-CH', { 
          day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' 
        });
        const actionClass = t.action === 'BUY_UP' ? 'buy-up' : 'buy-down';
        const typeClass = t.isReal ? 'real' : 'paper';
        const pnl = t.pnl !== null ? (t.pnl >= 0 ? `+$${t.pnl.toFixed(2)}` : `-$${Math.abs(t.pnl).toFixed(2)}`) : '-';
        
        row.innerHTML = `
          <td>${date}</td>
          <td>${t.strategy}</td>
          <td class="${actionClass}">${t.action}</td>
          <td>${(t.entryPrice * 100).toFixed(1)}%</td>
          <td>$${t.size.toFixed(2)}</td>
          <td class="${typeClass}">${t.isReal ? 'üí∞ REAL' : 'üìù Paper'}</td>
          <td>${pnl}</td>
        `;
        tbody.appendChild(row);
      }
    }

    // Load on start
    loadData();
    
    // Auto-refresh every 30s
    setInterval(loadData, 30000);
  </script>
</body>
</html>
